# Chapter 02 셰이더 101 

- GL 셰이딩 언어(GLSL) 를 자세히 다룹니다.

1. 웹지엘 그래픽 파이프라인의 개요.
2. 고정 기능 셰이더와 현대 프로그래밍 가능 셰이더의 차이.
3. GLSL 에서 정점 셰이더와 프래그먼트 셰이더의 역할.
4. 웹지엘 애플리케이션에서 셰이더를 생성하고 사용하는 방법.
5. 원시 타입과 내장 함수를 비롯한 GLSL 에 대한 자세한 설명.
6. 절차적 프래그먼트 셰이더 예제.



<h2>고정 기능 셰이더와 프로그래밍 기능 셰이더</h2>


초기 이미지 정의 - 정점 위치 및 이들 점과 관련한 색상, 법선, 벡터, 텍스처 좌표 같은 정보로 구성 됩니다.


고정 기능은 말 그대로 매우 제한적입니다.
하지만 - 좀 더 빠르게 쉽게 생성 가능.


프로그래밍 가능 파이프라인의 구성 요소는 정점 프로그램과 프래그먼트 프로그램을 사용하는 데 이 둘을 가리켜 한꺼번에 부를 떈 셰이더라고 합니다. 

이들 셰이더는 현대 컴퓨터에서 볼 수 있는 강력한 그래픽 처리 유닛(GPU)에서 실행됩니다.





<h2>GL 셰이딩 언어</h2>

같은 웹 파일 내 <script> 태그 안에 각각 'x-shader/x-vertex' 또는 'x-shader/x-fragment' 타입을 사용 해 VS 와 FS 소스를 임베드 합니다.

VS 및 FS를 외부 파일에 집어넣고 Ajax 로 로드합니다.





<h2>셰이더의 역할</h2>

VS 및 FS는 최종 이미지의 렌더링을 위해 상호 협력적인 고유 역할을 가지고 있습니다.


정점 셰이더(VS) 

`최종 정점 위치`
더불어 선택적으로 (정점 법선, 텍스처, 광원, 색상, FS 로 값 넘겨주기) 
VS는 최소한 gl_Position 을 설정해야 합니다.

``` javascript
<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
void main(void) {
    gl_Position = aVertexPosition;
}
</script>
```



프래그먼트 셰이더(FS) 

- 각 픽셀(원시 도형(들)의 래스터하된 영역)에 대해 작업 한다.
FS는 최종 픽셀별 색상과 텍스처 좌표를 계산하며 안개 같은 효과를 만드는 데도 사용합니다.


정리 FS 다음 수행.

`각 픽셀의 최종 색상을 설정하기 위한 정점 값을 보관`
선택적 텍스처 룩업을 수행, 프래그먼트를 버림. 


``` javascript
// 프래그먼트 색상을 설정해야 합니다.
<script id="shader-fs" type="x-shader/x-fragment">
    void main(void) {
        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
    }
</script>
```



<h2>기본 사용법</h2>


셰이더 프로그램의 설정.

- WebGLProgram 객체이며 각 셰이더는 WebGLShader 객체입니다.

``` javascript
let vertexShader = null,
fragmentShader = null,
shaderProgram = null; 
```

``` javascript
// 1. 셰이더를 생성합니다.
vertexShader = gl.createShader(GL.VERTEX_SHADER);
fragmentShader = gl.createShader(GL.FRAGMENT_SHADER); 

// 2. 각 셰이더의 소스 코드를 설정합니다.
<script id="shader-vs" type="x-shader/x-vertex">

</script>

<script id="shader-fs" type="x-shader/x-fragment">

</script>

let vertex_source = document.getElementById('shader-vs')
let fragment_source = document.getElementById('shader-fs')

gl.shaderSource(vertexShader, vertex_source);
gl.shaderSource(fragmentShader, fragment_source); 


// 3. 각 셰이더를 컴파일하고 에러를 검사합니다.
gl.compileShader(vertexShader);
if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS..))
    alert('Error compiling vertex shader: " + gl.getShaderInfoLog(vertexShader)); 

gl.compileShader(fragmentShader);
if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STAT..)
    alert('Error compiling fragment shader: " + gl.getShaderInfoLog(fragmentShader)); )

// 4. 프로그램을 생성합니다.
shaderProgram = gl.createProgram();

// 5. 셰이더를 프로그램에서 첨부합니다.
gl.attachShader(shaderProgram, vertexShader);
gl.attachShader(shaderProgram, fragmentShader); 

// 6. 프로그램을 연결하고 에러를 검사합니다.
gl.linkProgram(shaderProgram);
if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS); 
    alert('unable to initalize the shader program'));

// 7. 웹지엘이 우리 프로그램을 사용하게 합니다.
gl.useProgram(shaderProgram); 
```





<h3>정리 작업</h3>

프로그램에서 셰이더를 제거 하려면 반대 절차를 수행 해야 합니다.

``` javascript
// 1. 프로그램에서 셰이더를 연결 해제합니다.
gl.detachShader(shaderProgram, vertexShader);
gl.detachShader(shaderProgram, fragmentShader); 

// 2. 각 셰이더를 삭제합니다.
gl.deleteShader(vertexShader);
gl.deleteShader(fragmentShader);

// 3. 프로그램을 삭제합니다.
gl.deleteProgram(shaderProgram); 
```



useProgram 을 호출함으로써 각 셰이더 사이에서 전환할 수도 있습니다.
gl.useProgram(shaderProgram) 


<h2>Ajax 를 통한 셰이더 로딩</h2>

어플리케이션 파일을 좀 더 간결하게 만들고 모듈화를 하려면? 
Ajax 를 활용해 별도의 외부 파일로부터 셰이더를 로드해야 합니다.


`XMLHttpRequestObject` 외부 파일로부터 Ajax 컨텐츠를 로드하려면 ?
XMLHttpRequestObject(XHR) 를 직접 사용하기 위해 일반 자바스크립트를 사용할 수 있습니다.

XHR은 클라이언트에서 서버로 요청을 보내고 페이지를 재로드하거나 사용자의 브라우저 사용 경험을 방해하지 않고 응답을 받을 수 있습니다.

XML : 전송하는 문서 형식, JSON, HTML, 또는 일반 텍스트.
HTTP : 사용하는 프로토콜, HTTPS 가 될수도.
Request : 행동, 응답을 참조.


더불어 요청은 다른 호출을 방해하지 않게끔 비동기적으로 호출 할 수 있습니다.


readyState 및 status 속성을 관찰합니다.
여기서 XMLHttpRequestObject 를 간단히 보자.

``` javascript
let fs_source = null,
    vs_source = null;

let xhr = new XMLHttpRequest();
// 동기적 요청 시 3번쨰 파라미터를 false로 설정해야 합니다.
xhr.open('GET', './shader.vs', false); 
// mine 타입을 오버라이드해야 합니다.
xhr.overrideMimeType('text/xml');
xhr.send(null); 

// 만약 DONE 상태가 된다면? 상태를 검사합니다. 
if (xhr.readyState == xhr.DONE) {
    if (xhr.status === 200) { // 200 이면 성공. 
        vs_source = xhr.responseXML.documentElement.firstChild 
    } else {
        console.error('Error: ' + xtr.statusText); 
    }
}
xhr.open('GET', ./shader.fs', false);
xhr.send(null);
```





<h2>GLSL 명세?</h2>

ASCII 문자의 서브셋과 캐리지 리턴 및/또는 라인 피드를 사용해 각 줄을 끝냅니다.



`원시 타입`

vec2, vec3, vec4, lev2, lev3, vec4, bvec2, bvec3, bvec4 -> 1x2, 1x3, 1x4 크기 및 각각 float, integer, bool 타입의 벡터.

mat2, mat3, mat4 : 2x2, 3x3, 4x4 크기의 부동 소수 매트릭스.
sampler2D, samplerCube : 2D 또는 큐브 매핑된 텍스처에 대한 핸들.



또 좀 더 복잡한 타입을 보관하기 위해 구조체를 생성할 수도 있습니다.

``` javascript
struct mySruct {
    vec3 something;
    mat4 somethingElse;
}
```


`제한자`

GLSL 변수에 사용 할 수 있는 선택 제한자 몇 개를 가지고 있습니다.

이들 제한자는 저장 제한자, 파라미터 제한자, 정확도 제한자, 불변 제한자 범주 중 한 곳에 속합니다.


`저장 제한자.`

- 저장 제한자는 변수 스코프 및 웹지엘 프로그램과의 관계를 나타냅니다.
  
변수는 attribute vec3 aColor 처럼 어트리뷰트 저장 제한자를 사용해 선언 할 수 있습니다.

const : 읽기 전용.
uniform : 전체 원시 타입 사이에서 값이 일정.
attribute : 웹지엘 어플리케이션에서 정점별 vs 정보.
varying : vs 쓰기, fs 읽기.


`파라미터 제한자.`

in : 파라미터를 함수로 넘겨준다.
out : 함수 밖으로 파라미터를 넘겨주지만 파라미터가 초기화돼 있지 않다.
inout : 함수에서 밖으로 넘겨주는 초기화된 파라미터.


GLSL 3가지 종류의 정확도 제한자가 있습니다.

1. highp : 정점 언어에 필요한 최소한의 요구 조건 총족.
2. mediump 는 FS 에 필요한 최소한의 정확도를 총족.
3. lowp는 medium 보다는 덜하지만 여전히 색상 채널의 값을 완전히 나타냅니다.


불변 제한자.
- 끝으로 불변 제한자가 있습니다. 이 제한자는 변수를 더 이상 수정 할 수 없게 됩니다.


제한자 순서.

제한자 순서는 중요합니다.

1. 변수의 경우 불변 제한자.
2. 저장 제한자
3. 정확도 제한자 순서.

``` javascript
invariant uniform highp mat4 m;
void myFunc(const in lowp c){ ; }
```



내장 변수.

- GLSL 여러 개의 내장 변수를 갖고 있습니다.

``` javascript
변수        타입        설명        사용하는 곳             input/output 
gl_Position vec4     정점 위치      VS                       output 
gl_pointSize float   점 크기        VS                       output 
gl_FragCoord  vec4   프레임 버퍼 내 프레그먼트 위치     FS     input 
gl_FrontFacing bool  프래그먼트가 앞면인지 뒷면인지 여부   FS   input 
gl_PointCoord  vec2  점 내에서의 프래그먼트 위치       FS       input   
gl_FragColor  vec4   최종 프래그먼트 색상           FS          output 
gl_FragData[n] vec4  색상 점부 값 n에 대한 프래그먼트 색상 FS    output  
```



내장 상수.

웹지엘에는 내장 상수도 있습니다.

- 이들 값은 구현체 독립적 값을 갖고 있으며 각각 최소 요구 조건은 다음과 같습니다.

``` javascript
const mediump int gl_MaxVertexAttribs = 8;
const mediump int gl_MaxVertexUniformVectors = 128;
const mediump int gl_MaxVaryingVectors = 8; 
const mediump int gl_MaxVertexTextureImageUnits = 0; 
... 
```



벡터 성분.

편의상 숫자 배열 외 벡터 성분도 한 글자로 쉽게 접근할 수 있습니다.

``` javascript
좌표 위치 및 법선 : {x,y,z,w}
색상 : {r,g,b,a}
텍스처 : {s,t,p,d}
```


텍스처의 세 번쨰 성분 r은 색상을 구성하는 빨간색과 구분하기 위해 p로 대체.

``` javascript
vec4 green = vec4(0.0, 1.0, 0.0, 1.0);
vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
vec4 final_color;

final_color = vec4(green.rg, blue.ba);
final_color.rgb = green.rrr;
final_color.rg = green.gr;
final_color.g = (green.g + blue.g) * 0.5; 
```





벡터 및 매트릭스 연산.

- GLSL 벡터 및 매트릭스 연산을 기본 지원합니다.

벡터나 매트릭스에 스칼라를 적용하거나 덧셈 또는 뺄셈 연산을 적용하면 각 성분별로 계산이 수행됩니다.

``` javascript
vec3 u, v, w;
float f;
mat3 m;
```

스칼라 변수, 벡터, 매트릭스는 선언과 동시 초기화할 수도 있습니다.

``` javascript
float f = 1.4;
vec4 color = vec4(1.0, 0.0, 1.0, 1.0); // 빨간색.
vec4 a = vec2(1.0, 2.0);
vec2 b = vec2(3.0, 4.0); 

mat2 m = mat2(a,b);
// 열 우선 배열 - 열을 순서대로 배열합니다. 따라 위의 코드는.
// 다음 값이 들어 있는 매트릭스를 생성합니다.
// 1.0, 3.0 
// 2.0, 4.0 
// 그리고 메모리에 1.0, 2.0, 3.0, 4.0 으로 저장됩니다.


mat2 m = mat2(1.0, 0.0, 0.0, 1.0); // 2x2 항등 매트릭스.
mat2 m = mat2(1.0); // 마찬가지로 2x2 항등 매트릭스.
v = u + f;
```


위 코드의 결과는 다음과 같습니다.

``` javascript 
v.x = u.x + f;
v.y = u.y + f; 
v.z = u.z + f; 

w = u - v;
```

위 코드는 결과는 다음과 같습니다.

``` javascript
w.x = u.x - v.x;
w.y = u.y - v.y; 
w.z = u.z - v.z; 
```

GLSL 은 내적 및 외적을 수행하는 함수도 갖고 있습니다.
이들 함수는 각각 dot 과 corss 함수 입니다.

``` javascript
w = dot(u, v); 

w.x = u.x * v.x;
w.y = u.y * v.y; 
w.z = u.z * v.z; 

// 그리고 

w = cross(u, v); 

// 위 코드의 결과는 다음과 같습니다.
w.z = u.y * v.z * - u.z * v.y; 
w.y = u.z * v.x * - u.x * v.z; 
w.z = u.x * v.y * - u.y * v.x; 
```



내장 함수.

- 모든 함수의 입력 및 출력 타입은 float, vec2, vec3, vec4 가 될 수 있음.

T sin(T angle)은 
float sin(float angle) 또는 
vec2 sin(vec2 angle)을 나타낼 수 있지만 
vec2 sin(float angle)를 나타낼 수 없습니다.




각도 및 삼각 함수.

- 각도와 라디안을 변환하고 삼각 함수 값을 계산하는 GLSL의 기능이 있습니다.

GLSL의 삼각 함수.

T radens(T degress) - 각도를 라디안으로 변환.
... 

