# 이미지 처리

`WebGL에서 이미지를 그리기 위해서 텍스처를 사용해야 합니다.`
    
    - 렌더링 할 떄 WebGL이 픽셀 대신 clip space 좌표를 유추하는 것과 마찬가지.
        텍스처를 읽을 떄 WebGL은 텍스처 좌표를 유추합니다.
        텍스처 좌표는 텍스처 크기에 상관없이 0.0 에서 1.0 사이가 됩니다.

단 하나의 삼각형 (정확히는 2개의 삼각형)만 그리기 떄문에 
`사각형의 각 점이 텍스처의 어느 위치에 해당하는지 WebGL에 알려줘야 합니다.`

'varying' 이라고 불리는 특수 변수를 이용해 이 정보를 `vertex shader` 에서 `fragment shader` 로 전달해야 합니다.

이 변수는 변하기 떄문에 `varying` 이라 불립니다

- WebGL은 fragment shader를 사용해서 각 픽셀을 그릴 떄 vertex shader에 제공한 값을 보관합니다.

vertex shader를 사용해 텍스처 좌표 전달을 위한 속성을 추가한 다음 fragment shader 로 전달해야 합니다.

``` javascript
attribute vec2 a_texCoord;
...
varying vec2 v_texCoord; 

void main() {
    ...
    // Fragment shader로 texCoord 전달. 
    // GPU는 점들 사이의 값을 보간.
    v_texCoord = a_texCoord; 
}
```

다음 텍스처의 색상을 찾기 위해 fragment shader를 제공합니다.

``` javascript
<script id="fragment-shader-2d" type="x-shader/x-fragment">
precision mediump float; 

// 텍스처
uniform sampler2D u_image; 

// Vertex shader에서 전달된 texCoords 
varying vec2 v_texCoord; 

void main() {
    // 텍스처의 색상 탐색.
    gl_FragColor = texture2D(u_image, v_texCoord); 
}
```


마지막으로 이미지를 불러오고, 텍스처를 생성하고, 이미지를 텍스처로 복사해야 합니다.
브라우저에서 이미지를 비동기적으로 불러오기 떄문에 텍스처 로딩을 기다리도록 코드를 약간 변경해야 합니다.

- 불러오자마자 그리도록 할 겁니다.



``` javascript
function main() {
    var image = new Image();
    image.src = "http://someimage/on/our/server"; // 같은 도메인이여야 합니다!!
    image.onload = function() {
        render(image);
    }
}

function render(image) {
    ...
    // 이전에 작성한 모든 코드.
    ... 
    // 텍스처 좌표가 필요한 곳을 탐색.
    var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord'); 

    // 사각형의 텍스처 좌표 제공.
    var texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0, 
            0.0, 1.0,
            1.0, 0.0,
            1.0, 1.0 
        ]),
        gl.STATIC_DRAW
    );
    gl.enableVertexATtribArray(texCoordLocation);
    gl.vertexATtribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0); 

    // 텍스쳐 생성.
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture); 

    // 어떤 크기의 이미지로 렌더링할 수 있도록 매개변수 설정.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    
    // 텍스처에 이미지 업로드
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  ...
}
```



텍스처에 있는 각 픽셀의 왼쪽과 오른쪽의 픽셀을 평균화하는 fragment shader 입니다.

``` javascript
<script id="fragment-shader-2d" type="x-shader/x-fragment">
precision mediump float;

// 텍스처
uniform sampler2D u_image;

// Vertex shader에서 

</script>
```